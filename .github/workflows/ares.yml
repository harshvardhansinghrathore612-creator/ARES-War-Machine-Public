name: ARES ‚Äì GitHub Safe Vulnerability Pipeline

on:
  workflow_dispatch:

jobs:
  security-hunt:
    runs-on: ubuntu-latest
    timeout-minutes: 350

    steps:
    - name: Checkout Repo
      uses: actions/checkout@v4

    - name: Clean previous data
      run: |
        rm -rf output *.zip || true
        mkdir -p output/{recon,probe,crawl,vulns,secrets,specialized}

    - name: Install Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.21'

    - name: Install core dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y python3-pip python3-venv zip curl wget git ruby-full chromium chromium-driver xvfb libpcap-dev libxml2-dev libxslt1-dev
        # Set up proper PATH for Go binaries
        echo "GOPATH=$HOME/go" >> $GITHUB_ENV
        echo "$HOME/go/bin" >> $GITHUB_PATH
        echo "/usr/local/go/bin" >> $GITHUB_PATH

    - name: Install Go tools (GitHub-safe)
      run: |
        # Install Go tools with proper module support
        export GO111MODULE=on
        export GOPATH=$HOME/go
        export PATH=$PATH:$HOME/go/bin:/usr/local/go/bin
        
        go install github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest
        go install github.com/tomnomnom/assetfinder@latest
        go install github.com/projectdiscovery/dnsx/cmd/dnsx@latest
        go install github.com/projectdiscovery/httpx/cmd/httpx@latest
        go install github.com/projectdiscovery/katana/cmd/katana@latest
        go install github.com/lc/gau/v2/cmd/gau@latest
        go install github.com/hahwul/dalfox/v2@latest
        go install github.com/projectdiscovery/nuclei/v2/cmd/nuclei@latest
        go install github.com/tomnomnom/waybackurls@latest
        go install github.com/hakluke/hakrawler@latest
        go install github.com/tomnomnom/qsreplace@latest
        go install github.com/tomnomnom/unfurl@latest
        go install github.com/Emoe/kxss@latest
        # Install tfsec (Go tool)
        go install github.com/aquasecurity/tfsec/cmd/tfsec@latest
        # Copy binaries to /usr/local/bin for global access
        sudo cp $HOME/go/bin/* /usr/local/bin/ 2>/dev/null || true

    - name: Install Python tools
      run: |
        pip3 install --upgrade pip --user
        pip3 install truffleHog arjun checkov cloudsplaining s3scanner inql jwt_tool swagger-parser --user

    - name: Install GraphQLMap (from GitHub)
      run: |
        git clone --depth 1 https://github.com/swisskyrepo/GraphQLmap.git /tmp/GraphQLmap
        cd /tmp/GraphQLmap
        pip3 install -r requirements.txt --user
        # Create a wrapper script
        echo '#!/bin/bash
        cd /tmp/GraphQLmap
        python3 graphqlmap.py "$@"' | sudo tee /usr/local/bin/graphqlmap
        sudo chmod +x /usr/local/bin/graphqlmap

    - name: Install Prowler (AWS Security Tool)
      run: |
        pip3 install prowler --user

    - name: Install Jaeles
      run: |
        export GO111MODULE=on
        export GOPATH=$HOME/go
        export PATH=$PATH:$HOME/go/bin:/usr/local/go/bin
        
        go install github.com/jaeles-project/jaeles@latest
        sudo cp $HOME/go/bin/jaeles /usr/local/bin/
        jaeles config init
        git clone --depth 1 https://github.com/jaeles-project/jaeles-signatures.git $HOME/.jaeles/signatures-base || true

    - name: Download precompiled binaries
      run: |
        # gospider
        curl -L -o gospider-linux "https://github.com/hakluke/gospider/releases/latest/download/gospider-linux"
        chmod +x gospider-linux
        sudo mv gospider-linux /usr/local/bin/gospider
        # gitleaks (precompiled Go binary)
        curl -L -o gitleaks.tar.gz "https://github.com/gitleaks/gitleaks/releases/latest/download/gitleaks_linux_x64.tar.gz"
        tar -xzf gitleaks.tar.gz
        if [ -f "gitleaks" ]; then
          chmod +x gitleaks
          sudo mv gitleaks /usr/local/bin/gitleaks
        fi
        # Clean up
        rm -f gitleaks.tar.gz

    - name: Create Google Drive uploader
      run: |
        cat << 'EOF' > drive_upload.py
        import os, sys
        from google.oauth2.credentials import Credentials
        from googleapiclient.discovery import build
        from googleapiclient.http import MediaFileUpload

        def upload(file_path, folder_name):
            creds = Credentials(None,
                refresh_token=os.environ["GOOGLE_REFRESH_TOKEN"],
                token_uri="https://oauth2.googleapis.com/token",
                client_id=os.environ["GOOGLE_CLIENT_ID"],
                client_secret=os.environ["GOOGLE_CLIENT_SECRET"])
            service = build("drive","v3",credentials=creds)

            query = f"name='{folder_name}' and '{os.environ['GDRIVE_FOLDER_ID']}' in parents and trashed=false"
            res = service.files().list(q=query).execute().get("files",[])
            if res:
                folder_id = res[0]["id"]
            else:
                folder = service.files().create(
                    body={"name":folder_name,"mimeType":"application/vnd.google-apps.folder","parents":[os.environ["GDRIVE_FOLDER_ID"]]},
                    fields="id").execute()
                folder_id = folder["id"]

            media = MediaFileUpload(file_path)
            service.files().create(body={"name":os.path.basename(file_path),"parents":[folder_id]},media_body=media).execute()

        if __name__ == "__main__":
            upload(sys.argv[1], sys.argv[2])
        EOF
        # Install required Python packages for Google Drive API
        pip3 install google-api-python-client google-auth-httplib2 google-auth-oauthlib --user

    - name: Run ARES pipeline
      env:
        GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
        GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
        GOOGLE_REFRESH_TOKEN: ${{ secrets.GOOGLE_REFRESH_TOKEN }}
        GDRIVE_FOLDER_ID: ${{ secrets.GDRIVE_FOLDER_ID }}
        TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        # Create targets.txt if it doesn't exist
        if [ ! -f targets.txt ]; then
          echo "example.com" > targets.txt
        fi
        
        TARGET=$(head -n 1 targets.txt)

        tg() {
          curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_TOKEN/sendMessage" \
            -d chat_id="$TELEGRAM_CHAT_ID" \
            -d parse_mode="Markdown" \
            -d text="$1" >/dev/null
        }

        # Send start notification
        tg "üöÄ *ARES Pipeline Started* on $TARGET"

        # Function to handle errors and send notifications
        run_stage() {
          local stage_name=$1
          local stage_command=$2
          
          echo "Starting $stage_name..."
          if eval "$stage_command"; then
            tg "‚úÖ $stage_name completed successfully"
            return 0
          else
            tg "‚ùå *$stage_name FAILED* - Pipeline stopped"
            exit 1
          fi
        }

        ### STAGE 1: RECON
        run_stage "Reconnaissance" '
          subfinder -d $TARGET -silent > output/recon/subs.txt 2>/dev/null || true
          assetfinder --subs-only $TARGET >> output/recon/subs.txt 2>/dev/null || true
          sort -u output/recon/subs.txt > output/recon/final_subs.txt
          dnsx -l output/recon/final_subs.txt -silent > output/recon/dnsx.txt 2>/dev/null || true
          zip -j recon.zip output/recon/*
          python3 drive_upload.py recon.zip Stage_1_Recon
        '

        ### STAGE 2: PROBING
        run_stage "Probing" '
          httpx -l output/recon/final_subs.txt -silent > output/probe/live.txt 2>/dev/null || true
          zip -j probe.zip output/probe/*
          python3 drive_upload.py probe.zip Stage_2_Probe
        '

        ### STAGE 3: CRAWLING
        run_stage "Crawling" '
          katana -l output/probe/live.txt -silent > output/crawl/katana.txt 2>/dev/null || true
          gau $TARGET >> output/crawl/gau.txt 2>/dev/null || true
          waybackurls $TARGET >> output/crawl/wayback.txt 2>/dev/null || true
          hakrawler -url $TARGET > output/crawl/hakrawler.txt 2>/dev/null || true
          gospider -s $TARGET -o output/crawl/gospider.txt 2>/dev/null || true
          zip -j crawl.zip output/crawl/*
          python3 drive_upload.py crawl.zip Stage_3_Crawl
        '

        ### STAGE 4: PARAMS & XSS
        run_stage "Parameter & XSS Scan" '
          qsreplace -w output/crawl/katana.txt > output/crawl/qsreplace.txt 2>/dev/null || true
          kxss -list output/crawl/katana.txt > output/crawl/kxss.txt 2>/dev/null || true
          unfurl -u $TARGET > output/crawl/unfurl.txt 2>/dev/null || true
          zip -j params.zip output/crawl/*
          python3 drive_upload.py params.zip Stage_4_Params
        '

        ### STAGE 5: VULNS
        run_stage "Vulnerability Scanning" '
          nuclei -l output/probe/live.txt -severity high,critical -o output/vulns/nuclei.txt 2>/dev/null || true
          dalfox file output/crawl/katana.txt --skip-bav -o output/vulns/dalfox.txt 2>/dev/null || true
          zip -j vulns.zip output/vulns/*
          python3 drive_upload.py vulns.zip Stage_5_Vulns
        '

        ### STAGE 6: SECRETS
        run_stage "Secrets Detection" '
          trufflehog filesystem . > output/secrets/trufflehog.txt 2>/dev/null || true
          gitleaks detect --no-git -v > output/secrets/gitleaks.txt 2>/dev/null || true
          zip -j secrets.zip output/secrets/*
          python3 drive_upload.py secrets.zip Stage_6_Secrets
        '

        # Final success notification
        tg "üèÅ *ARES Pipeline COMPLETED SUCCESSFULLY* on $TARGET"
